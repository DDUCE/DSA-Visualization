<br><br><h2>Merge Sort Algorithm</h2>
<p>Merge Sort follows the rule of <b>Divide and Conquer</b>. But it doesn't divides the list into two halves. In merge sort the unsorted list is divided into N sublists, each having one element, because a list of one element is considered sorted. Then, it repeatedly merge these sublists, to produce new sorted sublists, and at lasts one sorted list is produced.</p>
<p>Merge Sort is quite fast, and has a time complexity of <b>O(n log n)</b>. It is also a stable sort, which means the "equal" elements are ordered in the same order in the sorted list.</p>
<hr/>
<h4>How Merge Sort Works</h4>
<p class="center"><img src="merge-sort.png" alt="Merge Sorting in Data Structures"></p>
<br/>
<p>Like we can see in the above example, merge sort first breaks the unsorted list into sorted sublists, and then keep merging these sublists, to finlly get the complete sorted list.</p>
<hr/>
<h4>Sorting using Merge Sort Algorithm</h4>
<pre class="cpp">/*  a[] is the array, p is starting index, that is 0, 
and r is the last index of array.  */

Lets take a[5] = {32, 45, 67, 2, 7} as the array to be sorted.

void <b>mergesort</b>(int a[], int p, int r)
{
  int q;
  if(p < r)
  {
    q = floor( (p+r) / 2);
    mergesort(a, p, q);
    mergesort(a, q+1, r);
    merge(a, p, q, r);
  }
}

void <b>merge</b>(int a[], int p, int q, int r)
{
  int b[5];     //same size of a[]
  int i, j, k;
  k = 0;
  i = p;
  j = q+1;
  while(i <= q && j <= r)
  {
    if(a[i] < a[j])
    {
      b[k++] = a[i++];       // same as b[k]=a[i]; k++; i++;
    }
    else
    {
      b[k++] = a[j++];
    }
  }
  
  while(i <= q)
  {
    b[k++] = a[i++];
  }
  
  while(j <= r)
  {
    b[k++] = a[j++];
  }
  
  for(i=r; i >= p; i--)
  {
    a[i] = b[--k];        // copying back the sorted list to a[]
  } 

}</pre>
<hr/>
<h4>Complexity Analysis of Merge Sort</h4>
<pre class="none">
<b>Worst Case Time Complexity :</b> O(n log n)
<b>Best Case Time Complexity :</b> O(n log n)
<b>Average Time Complexity :</b> O(n log n)
<b>Space Complexity : </b>O(n)
</pre>
<ul class="content">
<li>Time complexity of Merge Sort is O(n Log n) in all 3 cases (worst, average and best) as merge sort always divides the array in two halves and take linear time to merge two halves.</li>
<li>It requires equal amount of additional space as the unsorted list. Hence its not at all recommended for searching large unsorted lists.</li>
<li>It is the best Sorting technique for sorting <b>Linked Lists</b>.</li>